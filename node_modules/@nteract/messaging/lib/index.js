"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module messaging
 */
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const messages_1 = require("./messages");
// TODO: Deprecate
function createMessage(msg_type, fields = {}) {
    return Object.assign({}, messages_1.message({ msg_type }), fields);
}
exports.createMessage = createMessage;
// TODO: Deprecate
function createExecuteRequest(code = "") {
    return messages_1.executeRequest(code, {});
}
exports.createExecuteRequest = createExecuteRequest;
/**
 * operator for getting all messages that declare their parent header as
 * parentMessage's header.
 *
 * @param parentMessage The parent message whose children we should fetch
 *
 * @returns A function that takes an Observable of kernel messages and returns
 * messages that are children of parentMessage.
 */
exports.childOf = (parentMessage) => (source) => {
    const parentMessageID = parentMessage.header.msg_id;
    return rxjs_1.Observable.create((subscriber) => source.subscribe(msg => {
        // strictly speaking, in order for the message to be a child of the
        // parent message, it has to both be a message and have a parent to
        // begin with
        if (!msg || !msg.parent_header || !msg.parent_header.msg_id) {
            if (process.env.DEBUG === "true") {
                console.warn("no parent_header.msg_id on message", msg);
            }
            return;
        }
        if (parentMessageID === msg.parent_header.msg_id) {
            subscriber.next(msg);
        }
    }, 
    // be sure to handle errors and completions as appropriate and
    // send them along
    err => subscriber.error(err), () => subscriber.complete()));
};
/**
 * ofMessageType is an Rx Operator that filters on msg.header.msg_type
 * being one of messageTypes.
 *
 * @param messageTypes The message types to filter on
 *
 * @returns An Observable containing only messages of the specified types
 */
exports.ofMessageType = (...messageTypes) => {
    // Switch to the splat mode
    if (messageTypes.length === 1 && Array.isArray(messageTypes[0])) {
        return exports.ofMessageType(...messageTypes[0]);
    }
    return (source) => rxjs_1.Observable.create((subscriber) => source.subscribe(msg => {
        if (!msg.header || !msg.header.msg_type) {
            subscriber.error(new Error("no header.msg_type on message"));
            return;
        }
        if (messageTypes.indexOf(msg.header.msg_type) !== -1) {
            subscriber.next(msg);
        }
    }, 
    // be sure to handle errors and completions as appropriate and
    // send them along
    err => subscriber.error(err), () => subscriber.complete()));
};
/**
 * Create an object that adheres to the jupyter notebook specification.
 * http://jupyter-client.readthedocs.io/en/latest/messaging.html
 *
 * @param msg Message that has content which can be converted to nbformat
 *
 * @returns Message with the associated output type
 */
exports.convertOutputMessageToNotebookFormat = (msg) => (Object.assign({}, msg.content, { output_type: msg.header.msg_type }));
/**
 * Convert raw Jupyter messages that are output messages into nbformat style
 * outputs
 *
 * > o$ = iopub$.pipe(
 *     childOf(originalMessage),
 *     outputs()
 *   )
 */
exports.outputs = () => (source) => source.pipe(exports.ofMessageType("execute_result", "display_data", "stream", "error"), operators_1.map(exports.convertOutputMessageToNotebookFormat));
/**
 * Get all messages for updating a display output.
 */
exports.updatedOutputs = () => (source) => source.pipe(exports.ofMessageType("update_display_data"), operators_1.map(msg => (Object.assign({}, msg.content, { output_type: "display_data" }))));
/**
 * Get all the payload message content from an observable of jupyter messages
 *
 * > p$ = shell$.pipe(
 *     childOf(originalMessage),
 *     payloads()
 *   )
 */
exports.payloads = () => (source) => source.pipe(exports.ofMessageType("execute_reply"), operators_1.map(entry => entry.content.payload), operators_1.filter(Boolean), operators_1.mergeMap(p => rxjs_1.from(p)));
/**
 * Get all the execution counts from an observable of jupyter messages
 */
exports.executionCounts = () => (source) => source.pipe(exports.ofMessageType("execute_input"), operators_1.map(entry => entry.content.execution_count));
/**
 * Get all statuses of all running kernels.
 */
exports.kernelStatuses = () => (source) => source.pipe(exports.ofMessageType("status"), operators_1.map(entry => entry.content.execution_state));
__export(require("./messages"));
